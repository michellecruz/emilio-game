{"version":3,"sources":["Test.js","App.js","index.js"],"names":["camera","scene","renderer","canvas","geometry","texture","textureOpen","material","mesh","geometryKibble","textureKibble","materialKibble","meshKibble","kibbleID","raycaster","intersects","ghost","goal","temp","axis","shadowGroup","renderTarget","renderTargetBlur","shadowCamera","cameraHelper","depthMaterial","horizontalBlurMaterial","verticalBlurMaterial","plane","blurPlane","fillPlane","spheres","kibbleIDs","velocity","isTwirling","timeTwirling","isEating","isJumping","timeJumping","PLANE_WIDTH","window","innerWidth","PLANE_HEIGHT","innerHeight","CAMERA_HEIGHT","Test","state","timeElapsed","width","height","shadow","blur","darkness","opacity","color","kibbleEaten","emilio","position","x","y","z","rotation","init","container","document","querySelector","emilioCanvas","THREE","load","set","background","map","side","name","visible","add","needsUpdate","addShadow","addKibble","antialias","setPixelRatio","devicePixelRatio","setSize","replaceChild","domElement","getContext","setState","clientWidth","clientHeight","animate","requestAnimationFrame","normalize","cross","DefaultUp","rotateOnAxis","setFromMatrixPosition","matrixWorld","lerp","lookAt","updateProjectionMatrix","initialBackground","overrideMaterial","setRenderTarget","render","blurShadow","eatKibble","jump","twirl","eat","generateMipmaps","planeGeometry","rotateX","Math","PI","planeMaterial","transparent","scale","userData","value","onBeforeCompile","shader","uniforms","fragmentShader","replace","depthTest","depthWrite","HorizontalBlurShader","VerticalBlurShader","amount","tDiffuse","h","v","radius","i","abs","sin","push","computeBoundingBox","intersectObjects","length","object","uuid","includes","console","log","setTimeout","rotateCamera","up","body","classList","this","addEventListener","event","keyCode","className","id","Component","App","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.cfdec319.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport * as THREE from 'three';\n\nimport { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader.js';\nimport { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader.js';\n\nlet camera, scene, renderer, canvas;\nlet geometry, texture, textureOpen, material, mesh;\n\nlet geometryKibble, textureKibble, materialKibble, meshKibble;\nlet spheres = [];\n\nlet kibbleIDs = [],\n    kibbleID;\n\nlet radius = 100,\n    raycaster,\n    intersects,\n    ghost,\n    goal,\n    temp,\n    axis,\n    velocity = 1.4;\n\nlet isTwirling = false,\n    timeTwirling = 0,\n    isEating = false,\n    isJumping = false,\n    timeJumping = 0;\n\n// Shadow Variables\nlet shadowGroup, renderTarget, renderTargetBlur, shadowCamera, cameraHelper, depthMaterial, horizontalBlurMaterial, verticalBlurMaterial;\nlet plane, blurPlane, fillPlane;\n\nlet PLANE_WIDTH = window.innerWidth * 4,\n    PLANE_HEIGHT = window.innerHeight * 4,\n    CAMERA_HEIGHT = 500;\n      \n\nclass Test extends Component {\n  state = {\n    timeElapsed: 0,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    shadow: {\n      blur: 3.5,\n      darkness: 1,\n      opacity: 1,\n    },\n    plane: {\n      color: '#ffffff',\n      opacity: 1,\n    },\n    kibbleEaten: 0,\n    emilio: {\n      isEating: false,\n      isTwirling: null,\n      position: {\n        x: -700,\n        y: 500,\n        z: 0,\n      },\n      rotation: {\n        x: 0, //-0.1,\n        y: 6.5, //6.6,\n        z: 0, //-1.2,\n      },\n    }\n  }\n\n\n  init = () => {\n    let container = document.querySelector( '.container'),\n        emilioCanvas = document.querySelector('.emiliocanvas');\n\n    // Load textures.\n    texture = new THREE.TextureLoader().load( 'img/emilio-0-new.jpg' );\n    textureOpen = new THREE.TextureLoader().load( 'img/emilio-1-new.jpg' );\n    textureKibble = new THREE.TextureLoader().load( 'img/kibble.png' );\n    \n    // Set up the initial scene\n    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n    camera.position.set( 0, 400, 2000 );\n\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color( 0xffffff )\n\n    // Draw Emilio shape & texture\n    geometry = new THREE.SphereBufferGeometry( radius, 32, 32 );\n    material = new THREE.MeshBasicMaterial( { map: texture } );\n    material.side = THREE.DoubleSide;\n    mesh = new THREE.Mesh( geometry, material );\n    mesh.name = \"Emilio\";\n\n    // Add a ghost for the camera to follow.\n    ghost = new THREE.Mesh( );\n    ghost.visible = false\n    goal = new THREE.Object3D();\n    ghost.add( goal );\n    temp = new THREE.Vector3();\n    goal.position.set( 0, 0, 2000 );\n\n    // Set Emilio's initial position\n    mesh.position.x = this.state.emilio.position.x\n    mesh.position.y = this.state.emilio.position.y\n    mesh.position.z = this.state.emilio.position.z\n\n    // Emilio's initial rotation\n    mesh.rotation.x = this.state.emilio.rotation.x\n    mesh.rotation.y = this.state.emilio.rotation.y\n    mesh.rotation.z = this.state.emilio.rotation.z\n\n    // Needed in order to update Emilio's texture\n    mesh.material.map.needsUpdate = true;\n\n    // Add Emilio to the scene\n    scene.add(mesh);\n    scene.add(ghost);\n  \n    // Add the shadow!\n    this.addShadow();\n\n    // Scatter the treats!\n    this.addKibble();\n    \n    raycaster = new THREE.Raycaster();\n\n    // Draw the canvas.\n    renderer = new THREE.WebGLRenderer( { antialias: true } );\n    renderer.setPixelRatio( window.devicePixelRatio );\n    renderer.setSize( this.state.width, this.state.height );\n\n    // Replace div in the dom with new canvas.\n    container.replaceChild( renderer.domElement, emilioCanvas );\n    canvas = renderer.getContext('2d').canvas;\n\n    // Set width and height states to canvas width/height.\n    // Best not to keep calling window.InnerWidth/Height.\n    this.setState({\n      width: canvas.clientWidth,\n      height: canvas.clientHeight,\n    })\n  }\n\n\n  animate = () => {\n    // This creates the animation.\n    requestAnimationFrame(this.animate);\n\n    // Count seconds.\n    this.setState({\n      timeElapsed: this.state.timeElapsed + 1\n    })\n\n    // Emilio moves left by 10x every ~16.7 milliseconds.\n\n    ghost.position.x = mesh.position.x;\n    ghost.position.y = mesh.position.y;\n\n    shadowGroup.position.x = mesh.position.x;\n\n    // Physics/Gravity\n    // Make Emilio faster after he passes 100 kibble\n    if (this.state.kibbleEaten >= 99 &&\n        this.state.kibbleEaten <= 499) {\n      mesh.position.x += 30;\n      velocity = 1.8\n    } else if (this.state.kibbleEaten > 499 &&\n        this.state.kibbleEaten <= 999) {\n      mesh.position.x += 40;\n      velocity = 2.2\n    } else if (this.state.kibbleEaten > 999) {\n      mesh.position.x += 70;\n      velocity = 2.6\n    } else {\n      mesh.position.x += 20;\n    }\n\n    // If Emilio is in the air, move faster while falling to the ground.\n    if (mesh.position.y > 10) {\n      if (!isJumping) {\n        mesh.position.y -= 10\n      }\n\n      if (!isEating) {\n        mesh.material.map = textureOpen;\n      }\n    } else {\n      mesh.position.y = 0;\n    }\n\n    // Rotate Emilio based on his direction\n    axis = new THREE.Vector3();\n    // Axis orthogonal to forward vector\n    axis.set( mesh.position.x, mesh.position.y, 0 ).normalize();\n    axis.cross( THREE.Object3D.DefaultUp );\n    mesh.rotateOnAxis( axis, -0.05*velocity );\n\n\n    // Have the camera follow Emilio.\n    temp.setFromMatrixPosition(goal.matrixWorld);\n    camera.position.lerp(temp, 0.4);\n    camera.lookAt( ghost.position );\n    // camera.lookAt( ghost.position.x, ghost.position.y, spheres[1].position.z );\n    camera.updateProjectionMatrix();\n\n\n    // SHADOW\n    // remove the background\n    let initialBackground = scene.background;\n    scene.background = null;\n\n    // force the depthMaterial to everything\n    cameraHelper.visible = false;\n    scene.overrideMaterial = depthMaterial;\n\n    // render to the render target to get the depths\n    renderer.setRenderTarget( renderTarget );\n    renderer.render( scene, shadowCamera );\n\n    // and reset the override material\n    scene.overrideMaterial = null;\n    cameraHelper.visible = true;\n\n    this.blurShadow( this.state.shadow.blur );\n\n    // a second pass to reduce the artifacts\n    // (0.4 is the minimum blur amout so that the artifacts are gone)\n    this.blurShadow( this.state.shadow.blur * 0.4 );\n\n    // reset and render the normal scene\n    renderer.setRenderTarget( null );\n    scene.background = initialBackground;\n\n    // If Emilio is on the ground and is not eating,\n    // close his mouth.\n    if (mesh.position.y <= 0 && !isEating) {\n      mesh.material.map = texture;\n    }\n\n    // Start tracking if Emilio is eating kibble.\n    this.eatKibble();\n\n    // If Emilio is jumping, run this function. \n    if (isJumping) {\n      this.jump();\n    }\n\n    // This function contains logic for Emilio turning around.\n    if (isTwirling) {\n      timeTwirling += 1;\n    } else {\n      timeTwirling = 0;\n    }\n    this.twirl();\n\n    // If Emilio is eating, run this function.\n    if (isEating) {\n      this.eat();\n    }\n\n    // Render the screen.\n    renderer.render( scene, camera );\n    camera.updateProjectionMatrix();\n  }\n\n\n  addShadow = () => {\n    // the container, if you need to move the plane just move this\n    shadowGroup = new THREE.Group();\n    shadowGroup.position.y = -radius;\n\n    scene.add( shadowGroup );\n\n    // the render target that will show the shadows in the plane texture\n    renderTarget = new THREE.WebGLRenderTarget( 512, 512 );\n    renderTarget.texture.generateMipmaps = false;\n\n    // the render target that we will use to blur the first render target\n    renderTargetBlur = new THREE.WebGLRenderTarget( 512, 512 );\n    renderTargetBlur.texture.generateMipmaps = false;\n\n    // make a plane and make it face up\n    let planeGeometry = new THREE.PlaneBufferGeometry( PLANE_WIDTH, PLANE_HEIGHT ).rotateX( Math.PI / 2 );\n    let planeMaterial = new THREE.MeshBasicMaterial({\n      map: renderTarget.texture,\n      opacity: this.state.shadow.opacity,\n      transparent: true,\n    });\n\n    plane = new THREE.Mesh( planeGeometry, planeMaterial );\n    shadowGroup.add( plane );\n    // the y from the texture is flipped!\n    plane.scale.y = -1;\n\n    // the plane onto which to blur the texture\n    blurPlane = new THREE.Mesh( planeGeometry );\n    blurPlane.visible = false;\n    shadowGroup.add( blurPlane );\n\n    // the plane with the color of the ground\n    planeMaterial = new THREE.MeshBasicMaterial( {\n      color: this.state.plane.color,\n      opacity: this.state.plane.opacity,\n      transparent: true,\n    } );\n\n    fillPlane = new THREE.Mesh( planeGeometry, planeMaterial );\n    fillPlane.rotateX( Math.PI/2 );\n    shadowGroup.add( fillPlane );\n\n    // the camera to render the depth material from\n    shadowCamera = new THREE.OrthographicCamera( - PLANE_WIDTH / 2, PLANE_WIDTH / 2, PLANE_HEIGHT / 2, - PLANE_HEIGHT / 2, 0, CAMERA_HEIGHT );\n    shadowCamera.rotation.x = Math.PI / 2; // get the camera to look up\n    shadowGroup.add( shadowCamera );\n\n    cameraHelper = new THREE.CameraHelper( shadowCamera );\n\n    // like MeshDepthMaterial, but goes from black to transparent\n    depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.userData.darkness = { value: this.state.shadow.darkness };\n    depthMaterial.onBeforeCompile = function ( shader ) {\n      shader.uniforms.darkness = depthMaterial.userData.darkness;\n      shader.fragmentShader = `\n        uniform float darkness;\n        ${shader.fragmentShader.replace(\n      'gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n      'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );'\n    )}\n    `;\n    };\n    depthMaterial.depthTest = false;\n    depthMaterial.depthWrite = false;\n\n    horizontalBlurMaterial = new THREE.ShaderMaterial( HorizontalBlurShader );\n    horizontalBlurMaterial.depthTest = false;\n\n    verticalBlurMaterial = new THREE.ShaderMaterial( VerticalBlurShader );\n    verticalBlurMaterial.depthTest = false;\n  }\n\n\n  blurShadow = (amount) => {\n    blurPlane.visible = true;\n\n    // blur horizontally and draw in the renderTargetBlur\n    blurPlane.material = horizontalBlurMaterial;\n    blurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = amount * 1 / this.state.width*2; //256\n\n    renderer.setRenderTarget( renderTargetBlur );\n    renderer.render( blurPlane, shadowCamera );\n\n    // blur vertically and draw in the main renderTarget\n    blurPlane.material = verticalBlurMaterial;\n    blurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = amount * 1 / this.state.height*2; //256\n\n    renderer.setRenderTarget( renderTarget );\n    renderer.render( blurPlane, shadowCamera );\n\n    blurPlane.visible = false;\n  }\n\n\n  addKibble = () => {\n    // new THREE.BoxBufferGeometry( radius*2, radius*2, radius*2 );\n    geometryKibble = new THREE.CylinderBufferGeometry( radius, radius, radius*2, radius*2 ) //new THREE.SphereBufferGeometry( radius, 32, 32 );\n    materialKibble = new THREE.MeshBasicMaterial( { map: textureKibble, transparent: true } );\n    materialKibble.side = THREE.DoubleSide;\n\n    // Scatter 100 pieces of kibble in random positions\n    // Be sure not to go beyond the available area.\n    for (var i = 0; i < 100; i ++) {\n      meshKibble = new THREE.Mesh( geometryKibble, materialKibble );\n      meshKibble.rotation.x = mesh.rotation.x\n\n      meshKibble.rotation.y = mesh.rotation.y\n      meshKibble.rotation.z = mesh.rotation.z\n      // meshKibble.position.x = Math.random() * (80000 - 2000) + 2000;\n      meshKibble.position.x = 1000 + 400 * i\n      // meshKibble.position.y = Math.random() * (1000 - 0) + 0;\n      meshKibble.position.y = Math.abs(Math.sin(0.3 * i) * (1000 - 0) + 0);\n      meshKibble.scale.set(\n        meshKibble.scale.x = meshKibble.scale.x * 0.8,\n        meshKibble.scale.y = meshKibble.scale.y * 0.8,\n        meshKibble.scale.z = meshKibble.scale.z * 0.8,\n      )\n        \n      meshKibble.name = 'Kibble'\n\n      scene.add( meshKibble );\n      spheres.push( meshKibble );\n    }\n\n    for (var i = 0; i < 20; i ++) {\n      meshKibble = new THREE.Mesh( geometryKibble, materialKibble );\n      meshKibble.rotation.x = mesh.rotation.x\n\n      meshKibble.rotation.y = mesh.rotation.y\n      meshKibble.rotation.z = mesh.rotation.z\n      meshKibble.position.x = 5000 + 200 * i\n      meshKibble.position.y = 3000;\n      meshKibble.scale.set(\n        meshKibble.scale.x = meshKibble.scale.x * 0.8,\n        meshKibble.scale.y = meshKibble.scale.y * 0.8,\n        meshKibble.scale.z = meshKibble.scale.z * 0.8,\n      )\n        \n      meshKibble.name = 'Kibble'\n\n      scene.add( meshKibble );\n      spheres.push( meshKibble );\n    }\n\n    for (var i = 0; i < 20; i ++) {\n      meshKibble = new THREE.Mesh( geometryKibble, materialKibble );\n      meshKibble.rotation.x = mesh.rotation.x\n\n      meshKibble.rotation.y = mesh.rotation.y\n      meshKibble.rotation.z = mesh.rotation.z\n      meshKibble.position.x = 5000 + 200 * i\n      meshKibble.position.y = 3250;\n      meshKibble.scale.set(\n        meshKibble.scale.x = meshKibble.scale.x * 0.8,\n        meshKibble.scale.y = meshKibble.scale.y * 0.8,\n        meshKibble.scale.z = meshKibble.scale.z * 0.8,\n      )\n        \n      meshKibble.name = 'Kibble'\n\n      scene.add( meshKibble );\n      spheres.push( meshKibble );\n    }\n\n    for (var i = 0; i < 20; i ++) {\n      meshKibble = new THREE.Mesh( geometryKibble, materialKibble );\n      meshKibble.rotation.x = mesh.rotation.x\n\n      meshKibble.rotation.y = mesh.rotation.y\n      meshKibble.rotation.z = mesh.rotation.z\n      meshKibble.position.x = 5000 + 200 * i\n      meshKibble.position.y = 3500;\n      meshKibble.scale.set(\n        meshKibble.scale.x = meshKibble.scale.x * 0.8,\n        meshKibble.scale.y = meshKibble.scale.y * 0.8,\n        meshKibble.scale.z = meshKibble.scale.z * 0.8,\n      )\n        \n      meshKibble.name = 'Kibble'\n\n      scene.add( meshKibble );\n      spheres.push( meshKibble );\n    }\n  }\n  \n\n  eatKibble = () => {\n    // Use Raycaster to detect intersections.\n    raycaster.set(\n      mesh.position, // origin\n      new THREE.Vector3(-1, 1, 0), // direction\n    )\n\n    mesh.geometry.computeBoundingBox();\n\n    intersects = raycaster.intersectObjects( spheres );\n    isEating = false\n\n    if (intersects.length > 0) {\n      isEating = true\n\n      kibbleID = intersects[0].object.uuid\n      if (!kibbleIDs.includes(kibbleID)) {\n        kibbleIDs.push( kibbleID )\n\n        for (let i = 0; i < 10; i ++) {\n          this.setState({\n            emilio: {\n              isEating: true\n            },\n            kibbleEaten: this.state.kibbleEaten + 1,\n          })\n        }\n      }\n    } else {\n      isEating = false\n      this.setState({\n        emilio: {\n          isEating: false\n        }\n      })\n    }\n    console.log(kibbleIDs)\n\n    for ( let i = 0; i < intersects.length; i++ ) {\n      if (intersects.length > 0) {\n        if (intersects[i].object.name === 'Kibble') {\n          intersects[i].object.visible = false;\n\n          // if (mesh.scale.x < 2) {\n          //   mesh.scale.set(\n          //     mesh.scale.x + 0.01,\n          //     mesh.scale.y + 0.01,\n          //     mesh.scale.z + 0.01\n          //   );\n          //   mesh.geometry.computeBoundingSphere()\n          // }\n        }\n      }\n    }\n  }\n\n\n  eat = () => {\n    if (!isTwirling) {\n      mesh.rotation.x = -0.2\n      mesh.rotation.y = 6.5\n      mesh.rotation.z = -1.2\n    }\n\n    // TODO: Rewrite without using setTimeout!\n    requestAnimationFrame(() => {\n      if (mesh.material.map === texture) {\n        setTimeout(() => {\n          mesh.material.map = textureOpen\n\n          if (mesh.material.map === textureOpen) {\n            setTimeout(() => {\n              mesh.material.map = texture\n            }, 60);\n          }\n        }, 60);\n      } else {\n        setTimeout(() => {\n          mesh.material.map = texture\n        }, 60);\n      }\n    });\n  }\n\n\n  twirl = () => {\n    switch (isTwirling) {\n      case true:\n        mesh.rotation.z = -1.2;\n        mesh.rotation.x = -0.1;\n        mesh.rotation.y = timeTwirling;\n\n        if (mesh.rotation.y >= 34) {\n          mesh.rotation.y = 34.4\n        }\n        break\n      case false:\n        mesh.rotation.x = 0;\n        mesh.rotation.y = 6.5\n        break\n      default:\n    }\n  }\n\n\n  jump = () => {\n    timeJumping += timeJumping + 1;\n    \n    if (timeJumping <= 150) {\n      if (mesh.position.y < 4000) {\n        mesh.position.y += 30 + Math.sin(timeJumping)*2;\n      }\n    } else {\n      isJumping = false;\n      timeJumping = 0;\n    }\n  }\n\n\n  rotateCamera = () => {\n    if (this.state.width < this.state.height) {\n      PLANE_HEIGHT = window.innerWidth * 4;\n      PLANE_WIDTH = window.innerHeight * 4;\n      CAMERA_HEIGHT = 500;\n\n      camera.up = new THREE.Vector3(-1,0,0);\n      camera.updateProjectionMatrix();\n\n      document.body.classList.add('mobile');\n    }\n  }\n\n\n  componentDidMount() {\n    this.init();\n    this.animate();\n    this.rotateCamera();\n\n    document.addEventListener('keydown', event => {\n      if (event.keyCode === 32) {\n        isJumping = true;\n      }\n\n      if (event.keyCode === 84) {\n        switch (isTwirling) {\n          case false:\n            isTwirling = true\n            break\n          case true:\n            isTwirling = false\n            break\n        }\n      }\n    });\n\n    window.addEventListener('touchstart', () => {\n      isJumping = true\n    });\n  }\n\n\n  render() {\n    return (\n      <div className=\"container\">\n        <div className=\"note\">press the spacebar or tap to jump</div>\n        <div id=\"count\" className={`${this.state.emilio.isEating ? 'active' : ''}`}>{ this.state.kibbleEaten }</div>\n        <div className=\"emiliocanvas\"></div>\n      </div>\n    );\n  }\n}\n\n\nexport default Test;\n","import React from 'react';\nimport Test from './Test';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Test />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}