{"version":3,"sources":["Test.js","App.js","index.js"],"names":["camera","scene","renderer","canvas","geometry","texture","textureOpen","material","mesh","geometryKibble","textureKibble","materialKibble","meshKibble","raycaster","intersects","ghost","goal","temp","axis","shadowGroup","renderTarget","renderTargetBlur","shadowCamera","cameraHelper","depthMaterial","horizontalBlurMaterial","verticalBlurMaterial","plane","blurPlane","fillPlane","spheres","isTwirling","timeTwirling","isEating","isJumping","timeJumping","PLANE_WIDTH","window","innerWidth","PLANE_HEIGHT","innerHeight","CAMERA_HEIGHT","Test","state","width","height","shadow","blur","darkness","opacity","color","kibbleEaten","emilio","position","x","y","z","rotation","init","container","document","querySelector","emilioCanvas","THREE","load","set","background","map","side","name","visible","add","needsUpdate","addShadow","addKibble","antialias","setPixelRatio","devicePixelRatio","setSize","replaceChild","domElement","getContext","setState","clientWidth","clientHeight","generateMipmaps","planeGeometry","rotateX","Math","PI","planeMaterial","transparent","scale","userData","value","onBeforeCompile","shader","uniforms","fragmentShader","replace","depthTest","depthWrite","HorizontalBlurShader","VerticalBlurShader","blurShadow","amount","tDiffuse","h","setRenderTarget","render","v","radius","i","random","push","animate","requestAnimationFrame","sin","normalize","cross","DefaultUp","rotateOnAxis","setFromMatrixPosition","matrixWorld","lerp","lookAt","updateProjectionMatrix","initialBackground","overrideMaterial","eatKibble","jump","twirl","eat","computeBoundingBox","intersectObjects","length","object","setTimeout","rotateCamera","up","body","classList","this","addEventListener","event","keyCode","className","id","Component","App","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.b47fdef6.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport * as THREE from 'three';\n\nimport { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader.js';\nimport { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader.js';\n\nlet camera, scene, renderer, canvas;\nlet geometry, texture, textureOpen, material, mesh;\n\nlet geometryKibble, textureKibble, materialKibble, meshKibble;\nlet spheres = [];\n\nlet radius = 100,\n    raycaster,\n    intersects,\n    ghost,\n    goal,\n    temp,\n    axis;\n\nlet isTwirling = false,\n    timeTwirling = 0,\n    isEating = false,\n    isJumping = false,\n    timeJumping = 0;\n\n// Shadow Variables\nlet shadowGroup, renderTarget, renderTargetBlur, shadowCamera, cameraHelper, depthMaterial, horizontalBlurMaterial, verticalBlurMaterial;\nlet plane, blurPlane, fillPlane;\n\nlet PLANE_WIDTH = window.innerWidth * 4,\n    PLANE_HEIGHT = window.innerHeight * 4,\n    CAMERA_HEIGHT = 500;\n      \n\nclass Test extends Component {\n  state = {\n    width: window.innerWidth,\n    height: window.innerHeight,\n    shadow: {\n      blur: 3.5,\n      darkness: 1,\n      opacity: 1,\n    },\n    plane: {\n      color: '#ffffff',\n      opacity: 1,\n    },\n    kibbleEaten: 0,\n    emilio: {\n      isEating: false,\n      isTwirling: false,\n      position: {\n        x: -700,\n        y: 500,\n        z: 0,\n      },\n      rotation: {\n        x: 0, //-0.1,\n        y: 6.5, //6.6,\n        z: 0, //-1.2,\n      },\n    }\n  }\n\n\n  init = () => {\n    let container = document.querySelector( '.container'),\n        emilioCanvas = document.querySelector('.emiliocanvas');\n\n    // Load textures.\n    texture = new THREE.TextureLoader().load( 'img/emilio-0-new.jpg' );\n    textureOpen = new THREE.TextureLoader().load( 'img/emilio-1-new.jpg' );\n    textureKibble = new THREE.TextureLoader().load( 'img/kibble.png' );\n    \n    // Set up the initial scene\n    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n    camera.position.set( 0, 400, 2000 );\n\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color( 0xffffff )\n\n    // Draw Emilio shape & texture\n    geometry = new THREE.SphereBufferGeometry( radius, 32, 32 );\n    material = new THREE.MeshBasicMaterial( { map: texture } );\n    material.side = THREE.DoubleSide;\n    mesh = new THREE.Mesh( geometry, material );\n    mesh.name = \"Emilio\";\n\n    // Add a ghost for the camera to follow.\n    ghost = new THREE.Mesh( );\n    ghost.visible = false\n    goal = new THREE.Object3D();\n    ghost.add( goal );\n    temp = new THREE.Vector3();\n    goal.position.set( 0, 0, 2000 );\n\n    // Set Emilio's initial position\n    mesh.position.x = this.state.emilio.position.x\n    mesh.position.y = this.state.emilio.position.y\n    mesh.position.z = this.state.emilio.position.z\n\n    // Emilio's initial rotation\n    mesh.rotation.x = this.state.emilio.rotation.x\n    mesh.rotation.y = this.state.emilio.rotation.y\n    mesh.rotation.z = this.state.emilio.rotation.z\n\n    // Needed in order to update Emilio's texture\n    mesh.material.map.needsUpdate = true;\n\n    // Add Emilio to the scene\n    scene.add(mesh);\n    scene.add(ghost);\n  \n    // Add the shadow!\n    this.addShadow();\n\n    // Scatter the treats!\n    this.addKibble();\n    \n    raycaster = new THREE.Raycaster();\n\n    // Draw the canvas.\n    renderer = new THREE.WebGLRenderer( { antialias: true } );\n    renderer.setPixelRatio( window.devicePixelRatio );\n    renderer.setSize( this.state.width, this.state.height );\n\n    // Replace div in the dom with new canvas.\n    container.replaceChild( renderer.domElement, emilioCanvas );\n    canvas = renderer.getContext('2d').canvas;\n\n    // Set width and height states to canvas width/height.\n    // Best not to keep calling window.InnerWidth/Height.\n    this.setState({\n      width: canvas.clientWidth,\n      height: canvas.clientHeight,\n    })\n  }\n\n\n  addShadow = () => {\n    // the container, if you need to move the plane just move this\n    shadowGroup = new THREE.Group();\n    shadowGroup.position.y = -radius;\n\n    scene.add( shadowGroup );\n\n    // the render target that will show the shadows in the plane texture\n    renderTarget = new THREE.WebGLRenderTarget( 512, 512 );\n    renderTarget.texture.generateMipmaps = false;\n\n    // the render target that we will use to blur the first render target\n    renderTargetBlur = new THREE.WebGLRenderTarget( 512, 512 );\n    renderTargetBlur.texture.generateMipmaps = false;\n\n    // make a plane and make it face up\n    let planeGeometry = new THREE.PlaneBufferGeometry( PLANE_WIDTH, PLANE_HEIGHT ).rotateX( Math.PI / 2 );\n    let planeMaterial = new THREE.MeshBasicMaterial({\n      map: renderTarget.texture,\n      opacity: this.state.shadow.opacity,\n      transparent: true,\n    });\n\n    plane = new THREE.Mesh( planeGeometry, planeMaterial );\n    shadowGroup.add( plane );\n    // the y from the texture is flipped!\n    plane.scale.y = -1;\n\n    // the plane onto which to blur the texture\n    blurPlane = new THREE.Mesh( planeGeometry );\n    blurPlane.visible = false;\n    shadowGroup.add( blurPlane );\n\n    // the plane with the color of the ground\n    planeMaterial = new THREE.MeshBasicMaterial( {\n      color: this.state.plane.color,\n      opacity: this.state.plane.opacity,\n      transparent: true,\n    } );\n\n    fillPlane = new THREE.Mesh( planeGeometry, planeMaterial );\n    fillPlane.rotateX( Math.PI/2 );\n    shadowGroup.add( fillPlane );\n\n    // the camera to render the depth material from\n    shadowCamera = new THREE.OrthographicCamera( - PLANE_WIDTH / 2, PLANE_WIDTH / 2, PLANE_HEIGHT / 2, - PLANE_HEIGHT / 2, 0, CAMERA_HEIGHT );\n    shadowCamera.rotation.x = Math.PI / 2; // get the camera to look up\n    shadowGroup.add( shadowCamera );\n\n    cameraHelper = new THREE.CameraHelper( shadowCamera );\n\n    // like MeshDepthMaterial, but goes from black to transparent\n    depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.userData.darkness = { value: this.state.shadow.darkness };\n    depthMaterial.onBeforeCompile = function ( shader ) {\n      shader.uniforms.darkness = depthMaterial.userData.darkness;\n      shader.fragmentShader = `\n        uniform float darkness;\n        ${shader.fragmentShader.replace(\n      'gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n      'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );'\n    )}\n    `;\n    };\n    depthMaterial.depthTest = false;\n    depthMaterial.depthWrite = false;\n\n    horizontalBlurMaterial = new THREE.ShaderMaterial( HorizontalBlurShader );\n    horizontalBlurMaterial.depthTest = false;\n\n    verticalBlurMaterial = new THREE.ShaderMaterial( VerticalBlurShader );\n    verticalBlurMaterial.depthTest = false;\n  }\n\n\n  blurShadow = (amount) => {\n    blurPlane.visible = true;\n\n    // blur horizontally and draw in the renderTargetBlur\n    blurPlane.material = horizontalBlurMaterial;\n    blurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = amount * 1 / this.state.width*2; //256\n\n    renderer.setRenderTarget( renderTargetBlur );\n    renderer.render( blurPlane, shadowCamera );\n\n    // blur vertically and draw in the main renderTarget\n    blurPlane.material = verticalBlurMaterial;\n    blurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = amount * 1 / this.state.height*2; //256\n\n    renderer.setRenderTarget( renderTarget );\n    renderer.render( blurPlane, shadowCamera );\n\n    blurPlane.visible = false;\n  }\n\n\n  addKibble = () => {\n    // new THREE.BoxBufferGeometry( radius*2, radius*2, radius*2 );\n    geometryKibble = new THREE.CylinderBufferGeometry( radius, radius, radius*2, radius*2 ) //new THREE.SphereBufferGeometry( radius, 32, 32 );\n    materialKibble = new THREE.MeshBasicMaterial( { map: textureKibble, transparent: true } );\n    materialKibble.side = THREE.DoubleSide;\n\n    // Scatter 100 pieces of kibble in random positions\n    // Be sure not to go beyond the available area.\n    for (var i = 0; i < 200; i ++) {\n      meshKibble = new THREE.Mesh( geometryKibble, materialKibble );\n      meshKibble.rotation.x = mesh.rotation.x\n\n      meshKibble.rotation.y = mesh.rotation.y\n      meshKibble.rotation.z = mesh.rotation.z\n      meshKibble.position.x = Math.random() * (80000 - 2000) + 2000;\n      meshKibble.position.y = Math.random() * (1000 - 0) + 0;\n      meshKibble.scale.set(\n        meshKibble.scale.x = meshKibble.scale.x * 0.8,\n        meshKibble.scale.y = meshKibble.scale.y * 0.8,\n        meshKibble.scale.z = meshKibble.scale.z * 0.8,\n      )\n        \n      meshKibble.name = 'Kibble'\n\n      scene.add( meshKibble );\n      spheres.push( meshKibble );\n    }\n  }\n\n\n  animate = () => {\n    // This creates the animation.\n    requestAnimationFrame(this.animate);\n\n    // Emilio moves left by 10x every ~16.7 milliseconds.\n    mesh.position.x += 25;\n\n    ghost.position.x = mesh.position.x;\n    ghost.position.y = mesh.position.y;\n\n    shadowGroup.position.x = mesh.position.x;\n\n    // Make Emilio continue to get smaller up until minimum scale.\n    // if (mesh.scale.x > 0.2) {\n    //   mesh.scale.set(\n    //     mesh.scale.x -= 0.0005,\n    //     mesh.scale.y -= 0.0005,\n    //     mesh.scale.z -= 0.0005\n    //   );\n    // }\n\n    // Gravity\n    // If Emilio is in the air, move faster while falling to the ground.\n    if (mesh.position.y > 10) {\n      mesh.position.x += 1 * (mesh.position.y * 0.05) * Math.sin(1);\n      mesh.position.y -= 10;\n\n      if (!isEating) {\n        mesh.material.map = textureOpen;\n      }\n    } else {\n      mesh.position.y = 0;\n    }\n\n    // Rotate Emilio based on his direction\n    axis = new THREE.Vector3();\n    // Axis orthogonal to forward vector\n    axis.set( mesh.position.x, mesh.position.y, 0 ).normalize();\n    axis.cross( THREE.Object3D.DefaultUp );\n    mesh.rotateOnAxis( axis, -0.05 );\n\n\n    // Have the camera follow Emilio.\n    temp.setFromMatrixPosition(goal.matrixWorld);\n    camera.position.lerp(temp, 0.4);\n    camera.lookAt( ghost.position );\n    // camera.lookAt( ghost.position.x, ghost.position.y, spheres[1].position.z );\n    camera.updateProjectionMatrix();\n\n\n    // SHADOW\n    // remove the background\n    let initialBackground = scene.background;\n    scene.background = null;\n\n    // force the depthMaterial to everything\n    cameraHelper.visible = false;\n    scene.overrideMaterial = depthMaterial;\n\n    // render to the render target to get the depths\n    renderer.setRenderTarget( renderTarget );\n    renderer.render( scene, shadowCamera );\n\n    // and reset the override material\n    scene.overrideMaterial = null;\n    cameraHelper.visible = true;\n\n    this.blurShadow( this.state.shadow.blur );\n\n    // a second pass to reduce the artifacts\n    // (0.4 is the minimum blur amout so that the artifacts are gone)\n    this.blurShadow( this.state.shadow.blur * 0.4 );\n\n    // reset and render the normal scene\n    renderer.setRenderTarget( null );\n    scene.background = initialBackground;\n\n    // If Emilio is on the ground and is not eating,\n    // close his mouth.\n    if (mesh.position.y <= 0 && !isEating) {\n      mesh.material.map = texture;\n    }\n\n    // Start tracking if Emilio is eating kibble.\n    this.eatKibble();\n\n    // If Emilio is jumping, run this function. \n    if (isJumping) {\n      this.jump();\n    }\n\n    // If Emilio is twirling, run this function.\n    if (isTwirling) {\n      this.twirl();\n    }\n\n    if (isEating) {\n      this.eat();\n    }\n\n    // Render the screen.\n    renderer.render( scene, camera );\n    camera.updateProjectionMatrix();\n  }\n\n\n  eatKibble = () => {\n    // Use Raycaster to detect intersections.\n    raycaster.set(\n      mesh.position, // origin\n      new THREE.Vector3(-1, 1, 0), // direction\n    )\n\n    mesh.geometry.computeBoundingBox();\n\n    intersects = raycaster.intersectObjects( spheres );\n    isEating = false\n    if (intersects.length > 0) {\n      isEating = true\n\n      this.setState({\n        emilio: {\n          isEating: true\n        },\n        kibbleEaten: this.state.kibbleEaten + 1,\n      })\n    } else {\n      isEating = false\n      this.setState({\n        emilio: {\n          isEating: false\n        }\n      })\n    }\n\n    for ( let i = 0; i < intersects.length; i++ ) {\n      if (intersects.length > 0) {\n        if (intersects[i].object.name === 'Kibble') {\n          intersects[i].object.visible = false;\n\n          // if (mesh.scale.x < 2) {\n          //   mesh.scale.set(\n          //     mesh.scale.x + 0.01,\n          //     mesh.scale.y + 0.01,\n          //     mesh.scale.z + 0.01\n          //   );\n          //   mesh.geometry.computeBoundingSphere()\n          // }\n        }\n      }\n    }\n  }\n\n\n  eat = () => {\n    mesh.rotation.x = -0.2\n    mesh.rotation.y = 6.5\n    mesh.rotation.z = -1.2\n\n    requestAnimationFrame(() => {\n      if (mesh.material.map === texture) {\n        setTimeout(() => {\n          mesh.material.map = textureOpen\n\n          if (mesh.material.map === textureOpen) {\n            setTimeout(() => {\n              mesh.material.map = texture\n            }, 60);\n          }\n        }, 60);\n      } else {\n        setTimeout(() => {\n          mesh.material.map = texture\n        }, 60);\n      }\n    });\n  }\n\n\n  twirl = () => {\n    timeTwirling += 1;\n    // mesh.rotation.y = 0\n\n    if (timeTwirling < 110) {\n      if (timeTwirling < 30) {\n        mesh.rotation.z = -1.2;\n        mesh.rotation.x = -0.1;\n\n        let max = 30;\n        for (let i = 0; i < max; i++) {\n          mesh.rotation.y += 1;\n        }\n\n      } else if (timeTwirling >= 30 && timeTwirling < 70) {\n        // mesh.rotateOnAxis( axis, 0.9 );\n        if (timeTwirling >= 35 && timeTwirling < 40) {\n          mesh.material.map = textureOpen\n        } else if (timeTwirling >= 45 && timeTwirling < 50) {\n          mesh.material.map = texture\n        } else if (timeTwirling >= 50 && timeTwirling < 55) {\n          mesh.material.map = textureOpen\n        } else if (timeTwirling >= 55 && timeTwirling < 60) {\n          mesh.material.map = texture\n        } else if (timeTwirling >= 60 && timeTwirling < 65) {\n          mesh.material.map = textureOpen\n        } else {\n          mesh.material.map = texture\n        }\n\n      } else if (timeTwirling >= 70 && timeTwirling < 110) {\n        // mesh.rotation.y -= 1;\n\n        if (mesh.rotation.y <= 6.6) {\n          isTwirling = false;\n          timeTwirling = 0;\n        }\n      }\n    }\n  }\n\n\n  jump = () => {\n    timeJumping += timeJumping + 1;\n    \n    if (timeJumping <= 150) {\n      if (mesh.position.y < 4000) {\n        mesh.position.y += 30 + Math.sin(timeJumping)*2;\n      }\n    } else {\n      isJumping = false;\n      timeJumping = 0;\n    }\n\n    // if (mesh.position.y < 4000) {\n    //   if (mesh.position.y < 100) {\n    //     for (let i = 0; i <= 60; i++) {\n    //         mesh.position.y += 30;\n    //     }\n    //   }\n    // } else {\n    //   isJumping = false;\n    //   timeJumping = 0;\n    // }\n  }\n\n\n  rotateCamera = () => {\n    if (this.state.width < this.state.height) {\n      PLANE_HEIGHT = window.innerWidth * 4;\n      PLANE_WIDTH = window.innerHeight * 4;\n      CAMERA_HEIGHT = 500;\n\n      camera.up = new THREE.Vector3(-1,0,0);\n      camera.updateProjectionMatrix();\n\n      document.body.classList.add('mobile');\n    }\n  }\n\n\n  componentDidMount() {\n    this.init();\n    this.animate();\n    this.rotateCamera();\n\n    document.addEventListener('keydown', event => {\n      if (event.keyCode === 32) {\n        isJumping = true;\n      }\n\n      if (event.keyCode === 84) {\n        isTwirling = true;\n      }\n    });\n\n    window.addEventListener('touchstart', () => {\n      isJumping = true\n    });\n  }\n\n\n  render() {\n    return (\n      <div className=\"container\">\n        <div className=\"note\">press the spacebar or tap to jump</div>\n        <div id=\"count\" className={`${this.state.emilio.isEating ? 'active' : ''}`}>{ this.state.kibbleEaten }</div>\n        <div className=\"emiliocanvas\"></div>\n      </div>\n    );\n  }\n}\n\n\nexport default Test;\n","import React from 'react';\nimport Test from './Test';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Test />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}