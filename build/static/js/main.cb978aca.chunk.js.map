{"version":3,"sources":["Test.js","App.js","index.js"],"names":["camera","scene","renderer","canvas","geometry","texture","textureOpen","material","mesh","geometryKibble","textureKibble","materialKibble","meshKibble","raycaster","intersects","ghost","goal","temp","axis","shadowGroup","renderTarget","renderTargetBlur","shadowCamera","cameraHelper","depthMaterial","horizontalBlurMaterial","verticalBlurMaterial","plane","blurPlane","fillPlane","spheres","velocity","isTwirling","timeTwirling","isEating","isJumping","timeJumping","PLANE_WIDTH","window","innerWidth","PLANE_HEIGHT","innerHeight","CAMERA_HEIGHT","Test","state","timeElapsed","width","height","shadow","blur","darkness","opacity","color","kibbleEaten","emilio","position","x","y","z","rotation","init","container","document","querySelector","emilioCanvas","THREE","load","set","background","map","side","name","visible","add","needsUpdate","addShadow","addKibble","antialias","setPixelRatio","devicePixelRatio","setSize","replaceChild","domElement","getContext","setState","clientWidth","clientHeight","generateMipmaps","planeGeometry","rotateX","Math","PI","planeMaterial","transparent","scale","userData","value","onBeforeCompile","shader","uniforms","fragmentShader","replace","depthTest","depthWrite","HorizontalBlurShader","VerticalBlurShader","blurShadow","amount","tDiffuse","h","setRenderTarget","render","v","radius","i","random","push","animate","requestAnimationFrame","normalize","cross","DefaultUp","rotateOnAxis","setFromMatrixPosition","matrixWorld","lerp","lookAt","updateProjectionMatrix","initialBackground","overrideMaterial","eatKibble","jump","twirl","eat","computeBoundingBox","intersectObjects","length","object","setTimeout","sin","rotateCamera","up","body","classList","this","addEventListener","event","keyCode","className","id","Component","App","ReactDOM","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.cb978aca.chunk.js","sourcesContent":["import React, { Component } from 'react';\nimport * as THREE from 'three';\n\nimport { HorizontalBlurShader } from 'three/examples/jsm/shaders/HorizontalBlurShader.js';\nimport { VerticalBlurShader } from 'three/examples/jsm/shaders/VerticalBlurShader.js';\n\nlet camera, scene, renderer, canvas;\nlet geometry, texture, textureOpen, material, mesh;\n\nlet geometryKibble, textureKibble, materialKibble, meshKibble;\nlet spheres = [];\n\nlet radius = 100,\n    raycaster,\n    intersects,\n    ghost,\n    goal,\n    temp,\n    axis,\n    velocity = 1;\n\nlet isTwirling = false,\n    timeTwirling = 0,\n    timeTwirlingBack = 0,\n    isEating = false,\n    isJumping = false,\n    timeJumping = 0;\n\n// Shadow Variables\nlet shadowGroup, renderTarget, renderTargetBlur, shadowCamera, cameraHelper, depthMaterial, horizontalBlurMaterial, verticalBlurMaterial;\nlet plane, blurPlane, fillPlane;\n\nlet PLANE_WIDTH = window.innerWidth * 4,\n    PLANE_HEIGHT = window.innerHeight * 4,\n    CAMERA_HEIGHT = 500;\n      \n\nclass Test extends Component {\n  state = {\n    timeElapsed: 0,\n    width: window.innerWidth,\n    height: window.innerHeight,\n    shadow: {\n      blur: 3.5,\n      darkness: 1,\n      opacity: 1,\n    },\n    plane: {\n      color: '#ffffff',\n      opacity: 1,\n    },\n    kibbleEaten: 0,\n    emilio: {\n      isEating: false,\n      isTwirling: null,\n      position: {\n        x: -700,\n        y: 500,\n        z: 0,\n      },\n      rotation: {\n        x: 0, //-0.1,\n        y: 6.5, //6.6,\n        z: 0, //-1.2,\n      },\n    }\n  }\n\n\n  init = () => {\n    let container = document.querySelector( '.container'),\n        emilioCanvas = document.querySelector('.emiliocanvas');\n\n    // Load textures.\n    texture = new THREE.TextureLoader().load( 'img/emilio-0-new.jpg' );\n    textureOpen = new THREE.TextureLoader().load( 'img/emilio-1-new.jpg' );\n    textureKibble = new THREE.TextureLoader().load( 'img/kibble.png' );\n    \n    // Set up the initial scene\n    camera = new THREE.PerspectiveCamera( 50, window.innerWidth / window.innerHeight, 1, 10000 );\n    camera.position.set( 0, 400, 2000 );\n\n    scene = new THREE.Scene();\n    scene.background = new THREE.Color( 0xffffff )\n\n    // Draw Emilio shape & texture\n    geometry = new THREE.SphereBufferGeometry( radius, 32, 32 );\n    material = new THREE.MeshBasicMaterial( { map: texture } );\n    material.side = THREE.DoubleSide;\n    mesh = new THREE.Mesh( geometry, material );\n    mesh.name = \"Emilio\";\n\n    // Add a ghost for the camera to follow.\n    ghost = new THREE.Mesh( );\n    ghost.visible = false\n    goal = new THREE.Object3D();\n    ghost.add( goal );\n    temp = new THREE.Vector3();\n    goal.position.set( 0, 0, 2000 );\n\n    // Set Emilio's initial position\n    mesh.position.x = this.state.emilio.position.x\n    mesh.position.y = this.state.emilio.position.y\n    mesh.position.z = this.state.emilio.position.z\n\n    // Emilio's initial rotation\n    mesh.rotation.x = this.state.emilio.rotation.x\n    mesh.rotation.y = this.state.emilio.rotation.y\n    mesh.rotation.z = this.state.emilio.rotation.z\n\n    // Needed in order to update Emilio's texture\n    mesh.material.map.needsUpdate = true;\n\n    // Add Emilio to the scene\n    scene.add(mesh);\n    scene.add(ghost);\n  \n    // Add the shadow!\n    this.addShadow();\n\n    // Scatter the treats!\n    this.addKibble();\n    \n    raycaster = new THREE.Raycaster();\n\n    // Draw the canvas.\n    renderer = new THREE.WebGLRenderer( { antialias: true } );\n    renderer.setPixelRatio( window.devicePixelRatio );\n    renderer.setSize( this.state.width, this.state.height );\n\n    // Replace div in the dom with new canvas.\n    container.replaceChild( renderer.domElement, emilioCanvas );\n    canvas = renderer.getContext('2d').canvas;\n\n    // Set width and height states to canvas width/height.\n    // Best not to keep calling window.InnerWidth/Height.\n    this.setState({\n      width: canvas.clientWidth,\n      height: canvas.clientHeight,\n    })\n  }\n\n\n  addShadow = () => {\n    // the container, if you need to move the plane just move this\n    shadowGroup = new THREE.Group();\n    shadowGroup.position.y = -radius;\n\n    scene.add( shadowGroup );\n\n    // the render target that will show the shadows in the plane texture\n    renderTarget = new THREE.WebGLRenderTarget( 512, 512 );\n    renderTarget.texture.generateMipmaps = false;\n\n    // the render target that we will use to blur the first render target\n    renderTargetBlur = new THREE.WebGLRenderTarget( 512, 512 );\n    renderTargetBlur.texture.generateMipmaps = false;\n\n    // make a plane and make it face up\n    let planeGeometry = new THREE.PlaneBufferGeometry( PLANE_WIDTH, PLANE_HEIGHT ).rotateX( Math.PI / 2 );\n    let planeMaterial = new THREE.MeshBasicMaterial({\n      map: renderTarget.texture,\n      opacity: this.state.shadow.opacity,\n      transparent: true,\n    });\n\n    plane = new THREE.Mesh( planeGeometry, planeMaterial );\n    shadowGroup.add( plane );\n    // the y from the texture is flipped!\n    plane.scale.y = -1;\n\n    // the plane onto which to blur the texture\n    blurPlane = new THREE.Mesh( planeGeometry );\n    blurPlane.visible = false;\n    shadowGroup.add( blurPlane );\n\n    // the plane with the color of the ground\n    planeMaterial = new THREE.MeshBasicMaterial( {\n      color: this.state.plane.color,\n      opacity: this.state.plane.opacity,\n      transparent: true,\n    } );\n\n    fillPlane = new THREE.Mesh( planeGeometry, planeMaterial );\n    fillPlane.rotateX( Math.PI/2 );\n    shadowGroup.add( fillPlane );\n\n    // the camera to render the depth material from\n    shadowCamera = new THREE.OrthographicCamera( - PLANE_WIDTH / 2, PLANE_WIDTH / 2, PLANE_HEIGHT / 2, - PLANE_HEIGHT / 2, 0, CAMERA_HEIGHT );\n    shadowCamera.rotation.x = Math.PI / 2; // get the camera to look up\n    shadowGroup.add( shadowCamera );\n\n    cameraHelper = new THREE.CameraHelper( shadowCamera );\n\n    // like MeshDepthMaterial, but goes from black to transparent\n    depthMaterial = new THREE.MeshDepthMaterial();\n    depthMaterial.userData.darkness = { value: this.state.shadow.darkness };\n    depthMaterial.onBeforeCompile = function ( shader ) {\n      shader.uniforms.darkness = depthMaterial.userData.darkness;\n      shader.fragmentShader = `\n        uniform float darkness;\n        ${shader.fragmentShader.replace(\n      'gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );',\n      'gl_FragColor = vec4( vec3( 0.0 ), ( 1.0 - fragCoordZ ) * darkness );'\n    )}\n    `;\n    };\n    depthMaterial.depthTest = false;\n    depthMaterial.depthWrite = false;\n\n    horizontalBlurMaterial = new THREE.ShaderMaterial( HorizontalBlurShader );\n    horizontalBlurMaterial.depthTest = false;\n\n    verticalBlurMaterial = new THREE.ShaderMaterial( VerticalBlurShader );\n    verticalBlurMaterial.depthTest = false;\n  }\n\n\n  blurShadow = (amount) => {\n    blurPlane.visible = true;\n\n    // blur horizontally and draw in the renderTargetBlur\n    blurPlane.material = horizontalBlurMaterial;\n    blurPlane.material.uniforms.tDiffuse.value = renderTarget.texture;\n    horizontalBlurMaterial.uniforms.h.value = amount * 1 / this.state.width*2; //256\n\n    renderer.setRenderTarget( renderTargetBlur );\n    renderer.render( blurPlane, shadowCamera );\n\n    // blur vertically and draw in the main renderTarget\n    blurPlane.material = verticalBlurMaterial;\n    blurPlane.material.uniforms.tDiffuse.value = renderTargetBlur.texture;\n    verticalBlurMaterial.uniforms.v.value = amount * 1 / this.state.height*2; //256\n\n    renderer.setRenderTarget( renderTarget );\n    renderer.render( blurPlane, shadowCamera );\n\n    blurPlane.visible = false;\n  }\n\n\n  addKibble = () => {\n    // new THREE.BoxBufferGeometry( radius*2, radius*2, radius*2 );\n    geometryKibble = new THREE.CylinderBufferGeometry( radius, radius, radius*2, radius*2 ) //new THREE.SphereBufferGeometry( radius, 32, 32 );\n    materialKibble = new THREE.MeshBasicMaterial( { map: textureKibble, transparent: true } );\n    materialKibble.side = THREE.DoubleSide;\n\n    // Scatter 100 pieces of kibble in random positions\n    // Be sure not to go beyond the available area.\n    for (var i = 0; i < 200; i ++) {\n      meshKibble = new THREE.Mesh( geometryKibble, materialKibble );\n      meshKibble.rotation.x = mesh.rotation.x\n\n      meshKibble.rotation.y = mesh.rotation.y\n      meshKibble.rotation.z = mesh.rotation.z\n      meshKibble.position.x = Math.random() * (80000 - 2000) + 2000;\n      meshKibble.position.y = Math.random() * (1000 - 0) + 0;\n      meshKibble.scale.set(\n        meshKibble.scale.x = meshKibble.scale.x * 0.8,\n        meshKibble.scale.y = meshKibble.scale.y * 0.8,\n        meshKibble.scale.z = meshKibble.scale.z * 0.8,\n      )\n        \n      meshKibble.name = 'Kibble'\n\n      scene.add( meshKibble );\n      spheres.push( meshKibble );\n    }\n  }\n\n\n  animate = () => {\n    // This creates the animation.\n    requestAnimationFrame(this.animate);\n\n    // Count seconds.\n    this.setState({\n      timeElapsed: this.state.timeElapsed + 1\n    })\n\n    // Emilio moves left by 10x every ~16.7 milliseconds.\n    // mesh.position.x += 20;\n\n    ghost.position.x = mesh.position.x;\n    ghost.position.y = mesh.position.y;\n\n    shadowGroup.position.x = mesh.position.x;\n\n    // Physics/Gravity\n    // Make Emilio faster after he passes 100 kibble\n    if (this.state.kibbleEaten >= 99 &&\n      this.state.kibbleEaten <= 399) {\n      mesh.position.x += 30;\n      velocity = 1.1\n    } else if (this.state.kibbleEaten > 399) {\n      mesh.position.x += 40;\n      velocity = 1.2\n    } else {\n      mesh.position.x += 20;\n    }\n\n    // If Emilio is in the air, move faster while falling to the ground.\n    if (mesh.position.y > 10) {\n      if (!isJumping) {\n        mesh.position.y -= 10\n      }\n\n      if (!isEating) {\n        mesh.material.map = textureOpen;\n      }\n    } else {\n      mesh.position.y = 0;\n    }\n\n    // Rotate Emilio based on his direction\n    axis = new THREE.Vector3();\n    // Axis orthogonal to forward vector\n    axis.set( mesh.position.x, mesh.position.y, 0 ).normalize();\n    axis.cross( THREE.Object3D.DefaultUp );\n    mesh.rotateOnAxis( axis, -0.05*velocity );\n\n\n    // Have the camera follow Emilio.\n    temp.setFromMatrixPosition(goal.matrixWorld);\n    camera.position.lerp(temp, 0.4);\n    camera.lookAt( ghost.position );\n    // camera.lookAt( ghost.position.x, ghost.position.y, spheres[1].position.z );\n    camera.updateProjectionMatrix();\n\n\n    // SHADOW\n    // remove the background\n    let initialBackground = scene.background;\n    scene.background = null;\n\n    // force the depthMaterial to everything\n    cameraHelper.visible = false;\n    scene.overrideMaterial = depthMaterial;\n\n    // render to the render target to get the depths\n    renderer.setRenderTarget( renderTarget );\n    renderer.render( scene, shadowCamera );\n\n    // and reset the override material\n    scene.overrideMaterial = null;\n    cameraHelper.visible = true;\n\n    this.blurShadow( this.state.shadow.blur );\n\n    // a second pass to reduce the artifacts\n    // (0.4 is the minimum blur amout so that the artifacts are gone)\n    this.blurShadow( this.state.shadow.blur * 0.4 );\n\n    // reset and render the normal scene\n    renderer.setRenderTarget( null );\n    scene.background = initialBackground;\n\n    // If Emilio is on the ground and is not eating,\n    // close his mouth.\n    if (mesh.position.y <= 0 && !isEating) {\n      mesh.material.map = texture;\n    }\n\n    // Start tracking if Emilio is eating kibble.\n    this.eatKibble();\n\n    // If Emilio is jumping, run this function. \n    if (isJumping) {\n      this.jump();\n    }\n\n    // This function contains logic for Emilio turning around.\n    if (isTwirling) {\n      timeTwirlingBack = 0;\n      timeTwirling += 1;\n    } else {\n      timeTwirling = 0;\n      timeTwirlingBack += 1;\n    }\n    this.twirl();\n\n    // If Emilio is eating, run this function.\n    if (isEating) {\n      this.eat();\n    }\n\n    // Render the screen.\n    renderer.render( scene, camera );\n    camera.updateProjectionMatrix();\n  }\n\n\n  eatKibble = () => {\n    // Use Raycaster to detect intersections.\n    raycaster.set(\n      mesh.position, // origin\n      new THREE.Vector3(-1, 1, 0), // direction\n    )\n\n    mesh.geometry.computeBoundingBox();\n\n    intersects = raycaster.intersectObjects( spheres );\n    isEating = false\n    if (intersects.length > 0) {\n      isEating = true\n\n      this.setState({\n        emilio: {\n          isEating: true\n        },\n        kibbleEaten: this.state.kibbleEaten + 1,\n      })\n    } else {\n      isEating = false\n      this.setState({\n        emilio: {\n          isEating: false\n        }\n      })\n    }\n\n    for ( let i = 0; i < intersects.length; i++ ) {\n      if (intersects.length > 0) {\n        if (intersects[i].object.name === 'Kibble') {\n          intersects[i].object.visible = false;\n\n          // if (mesh.scale.x < 2) {\n          //   mesh.scale.set(\n          //     mesh.scale.x + 0.01,\n          //     mesh.scale.y + 0.01,\n          //     mesh.scale.z + 0.01\n          //   );\n          //   mesh.geometry.computeBoundingSphere()\n          // }\n        }\n      }\n    }\n  }\n\n\n  eat = () => {\n    if (!isTwirling) {\n      mesh.rotation.x = -0.2\n      mesh.rotation.y = 6.5\n      mesh.rotation.z = -1.2\n    }\n\n    // TODO: Rewrite without using setTimeout!\n    requestAnimationFrame(() => {\n      if (mesh.material.map === texture) {\n        setTimeout(() => {\n          mesh.material.map = textureOpen\n\n          if (mesh.material.map === textureOpen) {\n            setTimeout(() => {\n              mesh.material.map = texture\n            }, 60);\n          }\n        }, 60);\n      } else {\n        setTimeout(() => {\n          mesh.material.map = texture\n        }, 60);\n      }\n    });\n  }\n\n\n  twirl = () => {\n    switch (isTwirling) {\n      case true:\n        mesh.rotation.z = -1.2;\n        mesh.rotation.x = -0.1;\n        mesh.rotation.y = timeTwirling;\n\n        if (mesh.rotation.y >= 34) {\n          mesh.rotation.y = 34.4\n        }\n        break\n      case false:\n        mesh.rotation.x = 0;\n        mesh.rotation.y = 6.5\n        break\n      default:\n    }\n  }\n\n\n  jump = () => {\n    timeJumping += timeJumping + 1;\n    \n    if (timeJumping <= 150) {\n      if (mesh.position.y < 4000) {\n        mesh.position.y += 30 + Math.sin(timeJumping)*2;\n      }\n    } else {\n      isJumping = false;\n      timeJumping = 0;\n    }\n  }\n\n\n  rotateCamera = () => {\n    if (this.state.width < this.state.height) {\n      PLANE_HEIGHT = window.innerWidth * 4;\n      PLANE_WIDTH = window.innerHeight * 4;\n      CAMERA_HEIGHT = 500;\n\n      camera.up = new THREE.Vector3(-1,0,0);\n      camera.updateProjectionMatrix();\n\n      document.body.classList.add('mobile');\n    }\n  }\n\n\n  componentDidMount() {\n    this.init();\n    this.animate();\n    this.rotateCamera();\n\n    document.addEventListener('keydown', event => {\n      if (event.keyCode === 32) {\n        isJumping = true;\n      }\n\n      if (event.keyCode === 84) {\n        switch (isTwirling) {\n          case false:\n            isTwirling = true\n            break\n          case true:\n            isTwirling = false\n            break\n        }\n      }\n    });\n\n    window.addEventListener('touchstart', () => {\n      isJumping = true\n    });\n  }\n\n\n  render() {\n    return (\n      <div className=\"container\">\n        <div className=\"note\">press the spacebar or tap to jump</div>\n        <div id=\"count\" className={`${this.state.emilio.isEating ? 'active' : ''}`}>{ this.state.kibbleEaten }</div>\n        <div className=\"emiliocanvas\"></div>\n      </div>\n    );\n  }\n}\n\n\nexport default Test;\n","import React from 'react';\nimport Test from './Test';\nimport './App.css';\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Test />\n    </div>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}